//-----------------------------------------------------------------------------
// Entaro ChucK Developer!
// This is a chugin boilerplate, generated by chuginate!
//-----------------------------------------------------------------------------
// NOTE by default, chuginate generates a new UGen subclass in this file
//      but it is possible, of course, to create non-UGen classes in a chugin!
// To modify this generated file for a non-UGen class...
//      1. in QUERY->begin_class(), change "UGen" to a different ChucK class
//         (e.g., `QUERY->begin_class(QUERY, "Mirror", "Object");`)
//      2. remove or commment out the line containing QUERY->add_ugen_func()
//      3. that's it; the rest is no different for UGens/non-UGens
//-----------------------------------------------------------------------------
// NOTE once you have built this into a chugin (Mirror.chug), here are a few
//      helpful tools for testing / probing / verifying your new chugin!
//
// chuginate also generated a Mirror-test.ck boilerplate ChucK program
//      to help test your chugin (see Mirror-test.ck for more instructions)
//
// run `chuck --chugin-probe` to probe what chugins would be loaded, and
//      from where in the chugin search paths
//
// run `chuck -v3 --loop` to see what chugins are actually loaded at runtime,
//      with more info and error reporting than with --chugin-probe
//
// other helpful chugin-related flags include:
//      --chugin:<filename>
//      --chugin-path:(path) / -G(path)
//      --chugin-load:{on/off}
//
// for more information on command-line options:
//      https://chuck.stanford.edu/doc/program/options.html
// for more information on chugins:
//      https://chuck.stanford.edu/extend/
//-----------------------------------------------------------------------------
// happy chucking & chugging!
//-----------------------------------------------------------------------------

// include chugin header
#include "chugin.h"
#include "c-Mirror.h"

// general includes
#include <iostream>

// declaration of chugin constructor
CK_DLL_CTOR( mirror1_ctor );
CK_DLL_CTOR(mirror1_octor);
// declaration of chugin desctructor
CK_DLL_DTOR( mirror1_dtor );
CK_DLL_TICKF( mirror1_tickf );
CK_DLL_MFUN(mirror1_setMode);
CK_DLL_MFUN(mirror1_getMode);
// this is a special offset reserved for chugin internal data
t_CKINT mirror1_data_offset = 0;

// 2nd order
CK_DLL_CTOR(mirror2_ctor);
CK_DLL_CTOR(mirror2_octor);
CK_DLL_DTOR(mirror2_dtor);
CK_DLL_TICKF(mirror2_tickf);
CK_DLL_MFUN(mirror2_setMode);
CK_DLL_MFUN(mirror2_getMode);
t_CKINT mirror2_data_offset = 0;

// 3rd order
CK_DLL_CTOR(mirror3_ctor);
CK_DLL_CTOR(mirror3_octor);
CK_DLL_DTOR(mirror3_dtor);
CK_DLL_TICKF(mirror3_tickf);
CK_DLL_MFUN(mirror3_setMode);
CK_DLL_MFUN(mirror3_getMode);
t_CKINT mirror3_data_offset = 0;

// 4th order
CK_DLL_CTOR(mirror4_ctor);
CK_DLL_CTOR(mirror4_octor);
CK_DLL_DTOR(mirror4_dtor);
CK_DLL_TICKF(mirror4_tickf);
CK_DLL_MFUN(mirror4_setMode);
CK_DLL_MFUN(mirror4_getMode);
t_CKINT mirror4_data_offset = 0;

// 5th order
CK_DLL_CTOR(mirror5_ctor);
CK_DLL_CTOR(mirror5_octor);
CK_DLL_DTOR(mirror5_dtor);
CK_DLL_TICKF(mirror5_tickf);
CK_DLL_MFUN(mirror5_setMode);
CK_DLL_MFUN(mirror5_getMode);
t_CKINT mirror5_data_offset = 0;

//-----------------------------------------------------------------------------
// info function: ChucK calls this when loading/probing the chugin
// NOTE: please customize these info fields below; they will be used for
// chugins loading, probing, and package management and documentation
//-----------------------------------------------------------------------------
CK_DLL_INFO( Mirror )
{
    // the version string of this chugin, e.g., "v1.2.1"
    QUERY->setinfo( QUERY, CHUGIN_INFO_CHUGIN_VERSION, "v1.0.0" );
    // the author(s) of this chugin, e.g., "Alice Baker & Carl Donut"
    QUERY->setinfo( QUERY, CHUGIN_INFO_AUTHORS, "Everett M. Carpenter" );
    // text description of this chugin; what is it? what does it do? who is it for?
    QUERY->setinfo( QUERY, CHUGIN_INFO_DESCRIPTION, "A chugin for mirroring a soundfield across the three axes." );
    // (optional) URL of the homepage for this chugin
    QUERY->setinfo( QUERY, CHUGIN_INFO_URL, "" );
    // (optional) contact email
    QUERY->setinfo( QUERY, CHUGIN_INFO_EMAIL, "carpee2[at]rpi[dot]edu" );
}

//-----------------------------------------------------------------------------
// query function: ChucK calls this when loading the chugin
// modify this function to define this chugin's API and language extensions
//-----------------------------------------------------------------------------
CK_DLL_QUERY( Mirror )
{
    // generally, don't change this...
    QUERY->setname( QUERY, "Mirror" );

    // ------------------------------------------------------------------------
    // begin class definition(s); will be compiled, verified,
    // and added to the chuck host type system for use
    // ------------------------------------------------------------------------
    // NOTE to create a non-UGen class, change the second argument
    // to extend a different ChucK class (e.g., "Object")
    QUERY->begin_class( QUERY, "Mirror1", "UGen" );

    // register default constructor
    QUERY->add_ctor( QUERY, mirror1_ctor );
    QUERY->add_ctor(QUERY, mirror1_octor);
    QUERY->add_arg(QUERY, "int", "mode");
    // NOTE constructors can be overloaded like any other functions,
    // each overloaded constructor begins with `QUERY->add_ctor()`
    // followed by a sequence of `QUERY->add_arg()`

    // register the destructor (probably no need to change)
    QUERY->add_dtor( QUERY, mirror1_dtor );

    QUERY->add_mfun(QUERY, mirror1_getMode, "int", "mode");
    QUERY->add_mfun(QUERY, mirror1_setMode, "void", "mode");
    QUERY->add_arg(QUERY, "int", "newmode");

    // for UGens only: add tick function
    // NOTE a non-UGen class should remove or comment out this next line
    QUERY->add_ugen_funcf(QUERY, mirror1_tickf, NULL, 4, 4);
    // NOTE: if this is to be a UGen with more than 1 channel,
    // e.g., a multichannel UGen -- will need to use add_ugen_funcf()
    // and declare a tickf function using CK_DLL_TICKF
    // 
    // this reserves a variable in the ChucK internal class to store 
    // referene to the c++ class we defined above
    mirror1_data_offset = QUERY->add_mvar( QUERY, "int", "@m_data", false );

    // ------------------------------------------------------------------------
    // end the class definition
    // IMPORTANT: this MUST be called to each class definition!
    // ------------------------------------------------------------------------
    QUERY->end_class( QUERY );

    // 2nd order
    QUERY->begin_class(QUERY, "Mirror2", "UGen");
    QUERY->add_ctor(QUERY, mirror2_ctor);
    QUERY->add_ctor(QUERY, mirror2_octor);
    QUERY->add_arg(QUERY, "int", "mode");
    QUERY->add_mfun(QUERY, mirror2_getMode, "int", "mode");
    QUERY->add_mfun(QUERY, mirror2_setMode, "void", "mode");
    QUERY->add_arg(QUERY, "int", "newmode");
    QUERY->add_dtor(QUERY, mirror2_dtor);
    QUERY->add_ugen_funcf(QUERY, mirror2_tickf, NULL, 9, 9);
    mirror2_data_offset = QUERY->add_mvar(QUERY, "int", "@m_data", false);
    QUERY->end_class(QUERY);

    // 3rd order
    QUERY->begin_class(QUERY, "Mirror3", "UGen");
    QUERY->add_ctor(QUERY, mirror3_ctor);
    QUERY->add_ctor(QUERY, mirror3_octor);
    QUERY->add_arg(QUERY, "int", "mode");
    QUERY->add_mfun(QUERY, mirror3_getMode, "int", "mode");
    QUERY->add_mfun(QUERY, mirror3_setMode, "void", "mode");
    QUERY->add_arg(QUERY, "int", "newmode");
    QUERY->add_dtor(QUERY, mirror3_dtor);
    QUERY->add_ugen_funcf(QUERY, mirror3_tickf, NULL, 16, 16);
    mirror3_data_offset = QUERY->add_mvar(QUERY, "int", "@m_data", false);
    QUERY->end_class(QUERY);

    // 4th order
    QUERY->begin_class(QUERY, "Mirror4", "UGen");
    QUERY->add_ctor(QUERY, mirror4_ctor);
    QUERY->add_ctor(QUERY, mirror4_octor);
    QUERY->add_arg(QUERY, "int", "mode");
    QUERY->add_mfun(QUERY, mirror4_getMode, "int", "mode");
    QUERY->add_mfun(QUERY, mirror4_setMode, "void", "mode");
    QUERY->add_arg(QUERY, "int", "newmode");
    QUERY->add_dtor(QUERY, mirror4_dtor);
    QUERY->add_ugen_funcf(QUERY, mirror4_tickf, NULL, 25, 25);
    mirror4_data_offset = QUERY->add_mvar(QUERY, "int", "@m_data", false);
    QUERY->end_class(QUERY);

    // 5th order
    QUERY->begin_class(QUERY, "Mirror5", "UGen");
    QUERY->add_ctor(QUERY, mirror5_ctor);
    QUERY->add_ctor(QUERY, mirror5_octor);
    QUERY->add_arg(QUERY, "int", "mode");
    QUERY->add_mfun(QUERY, mirror5_getMode, "int", "mode");
    QUERY->add_mfun(QUERY, mirror5_setMode, "void", "mode");
    QUERY->add_arg(QUERY, "int", "newmode");
    QUERY->add_dtor(QUERY, mirror5_dtor);
    QUERY->add_ugen_funcf(QUERY, mirror5_tickf, NULL, 36, 36);
    mirror5_data_offset = QUERY->add_mvar(QUERY, "int", "@m_data", false);
    QUERY->end_class(QUERY);

    // wasn't that a breeze?
    return TRUE;
}

//-----------------------------------------------------------------------------
// dll functions: settings access functions for dlls
// modify this function to define this chugin's API and language extensions
//-----------------------------------------------------------------------------
// implementation for the default constructor
CK_DLL_CTOR( mirror1_ctor )
{
    // get the offset where we'll store our internal c++ class pointer
    OBJ_MEMBER_INT( SELF, mirror1_data_offset ) = 0;
    
    // instantiate our internal c++ class representation
    Mirror * m_obj = new Mirror( API->vm->srate(VM) );
    
    // store the pointer in the ChucK object member
    OBJ_MEMBER_INT( SELF, mirror1_data_offset ) = (t_CKINT)m_obj;
}

CK_DLL_CTOR(mirror1_octor)
{
    // get the offset where we'll store our internal c++ class pointer
    OBJ_MEMBER_INT(SELF, mirror1_data_offset) = 0;
    t_CKINT input = GET_NEXT_INT(ARGS);
    // instantiate our internal c++ class representation
    Mirror* m_obj = new Mirror(API->vm->srate(VM), input);

    // store the pointer in the ChucK object member
    OBJ_MEMBER_INT(SELF, mirror1_data_offset) = (t_CKINT)m_obj;
}

// implementation for the destructor
CK_DLL_DTOR( mirror1_dtor )
{
    // get our c++ class pointer
    Mirror * m_obj = (Mirror *)OBJ_MEMBER_INT( SELF, mirror1_data_offset );
    // clean up (this macro tests for NULL, deletes, and zeros out the variable)
    CK_SAFE_DELETE( m_obj );
    // set the data field to 0
    OBJ_MEMBER_INT( SELF, mirror1_data_offset ) = 0;
}

// implementation for tick function (relevant only for UGens)
CK_DLL_TICKF( mirror1_tickf )
{
    // get our c++ class pointer
    Mirror * m_obj = (Mirror *)OBJ_MEMBER_INT(SELF, mirror1_data_offset);
    
    int* weights = m_obj->getMirror();

    // invoke our tick function; store in the magical out variable
    if (m_obj)
    {
        memset(out, 0, sizeof(SAMPLE) * 4 * nframes); // clear
        for (int f = 0; f < nframes; f++)
        {
            for (int c = 0; c < 4; c++)
            {
                out[f * 4 + c] = in[f * 4 + c] * weights[c]; // search up weights and apply
            }
        }
    }

    // yes
    return TRUE;
}

// example implementation for setter
CK_DLL_MFUN( mirror1_setMode )
{
    // get our c++ class pointer
    Mirror * m_obj = (Mirror *)OBJ_MEMBER_INT( SELF, mirror1_data_offset );

    // get next argument
    // NOTE argument type must match what is specified above in CK_DLL_QUERY
    // NOTE this advances the ARGS pointer, so save in variable for re-use
    t_CKINT arg1 = GET_NEXT_INT( ARGS );
    
    m_obj->mode( arg1 );
}

// example implementation for setter
CK_DLL_MFUN(mirror1_getMode)
{
    // get our c++ class pointer
    Mirror* m_obj = (Mirror*)OBJ_MEMBER_INT(SELF, mirror1_data_offset);
    if (m_obj) RETURN->v_int = m_obj->lastMode;
    else RETURN->v_int = 0;
}
//==============================================================================
CK_DLL_CTOR(mirror2_ctor)
{
    OBJ_MEMBER_INT(SELF, mirror2_data_offset) = 0;
    Mirror* m_obj = new Mirror(API->vm->srate(VM));
    OBJ_MEMBER_INT(SELF, mirror2_data_offset) = (t_CKINT)m_obj;
}

CK_DLL_CTOR(mirror2_octor)
{
    OBJ_MEMBER_INT(SELF, mirror2_data_offset) = 0;
    t_CKINT input = GET_NEXT_INT(ARGS); // grab init mode
    Mirror* m_obj = new Mirror(API->vm->srate(VM), input);
    OBJ_MEMBER_INT(SELF, mirror2_data_offset) = (t_CKINT)m_obj;
}

CK_DLL_DTOR(mirror2_dtor)
{
    Mirror* m_obj = (Mirror*)OBJ_MEMBER_INT(SELF, mirror2_data_offset);
    CK_SAFE_DELETE(m_obj);
    OBJ_MEMBER_INT(SELF, mirror2_data_offset) = 0;
}

CK_DLL_TICKF(mirror2_tickf)
{
    Mirror* m_obj = (Mirror*)OBJ_MEMBER_INT(SELF, mirror2_data_offset);
    if (m_obj)
    {
        memset(out, 0, sizeof(SAMPLE) * 9 * nframes); // clear
        for (int f = 0; f < nframes; f++)
        {
            for (int c = 0; c < 9; c++)
            {
                out[f * 9 + c] = in[f * 9 + c] * m_obj->mirrorValues[c]; // search up weights and apply
            }
        }
    }
    return TRUE;
}

CK_DLL_MFUN(mirror2_setMode)
{
    Mirror* m_obj = (Mirror*)OBJ_MEMBER_INT(SELF, mirror2_data_offset);
    t_CKINT arg1 = GET_NEXT_INT(ARGS);

    m_obj->mode(arg1);
}

CK_DLL_MFUN(mirror2_getMode)
{
    Mirror* m_obj = (Mirror*)OBJ_MEMBER_INT(SELF, mirror2_data_offset);
    if (m_obj) RETURN->v_int = m_obj->lastMode;
    else RETURN->v_int = 0;
}

//==============================================================================
CK_DLL_CTOR(mirror3_ctor)
{
    OBJ_MEMBER_INT(SELF, mirror3_data_offset) = 0;
    Mirror* m_obj = new Mirror(API->vm->srate(VM));
    OBJ_MEMBER_INT(SELF, mirror3_data_offset) = (t_CKINT)m_obj;
}

CK_DLL_CTOR(mirror3_octor)
{
    OBJ_MEMBER_INT(SELF, mirror3_data_offset) = 0;
    t_CKINT input = GET_NEXT_INT(ARGS); // grab init mode
    Mirror* m_obj = new Mirror(API->vm->srate(VM), input);
    OBJ_MEMBER_INT(SELF, mirror3_data_offset) = (t_CKINT)m_obj;
}

CK_DLL_DTOR(mirror3_dtor)
{
    Mirror* m_obj = (Mirror*)OBJ_MEMBER_INT(SELF, mirror3_data_offset);
    CK_SAFE_DELETE(m_obj);
    OBJ_MEMBER_INT(SELF, mirror3_data_offset) = 0;
}

CK_DLL_TICKF(mirror3_tickf)
{
    Mirror* m_obj = (Mirror*)OBJ_MEMBER_INT(SELF, mirror3_data_offset);
    if (m_obj)
    {
        memset(out, 0, sizeof(SAMPLE) * 16 * nframes); // clear
        for (int f = 0; f < nframes; f++)
        {
            for (int c = 0; c < 16; c++)
            {
                out[f * 16 + c] = in[f * 16 + c] * m_obj->mirrorValues[c]; // search up weights and apply
            }
        }
    }
    return TRUE;
}

CK_DLL_MFUN(mirror3_setMode)
{
    Mirror* m_obj = (Mirror*)OBJ_MEMBER_INT(SELF, mirror3_data_offset);
    t_CKINT arg1 = GET_NEXT_INT(ARGS);

    m_obj->mode(arg1);
}

CK_DLL_MFUN(mirror3_getMode)
{
    Mirror* m_obj = (Mirror*)OBJ_MEMBER_INT(SELF, mirror3_data_offset);
    if (m_obj) RETURN->v_int = m_obj->lastMode;
    else RETURN->v_int = 0;
}

//==============================================================================
CK_DLL_CTOR(mirror4_ctor)
{
    OBJ_MEMBER_INT(SELF, mirror4_data_offset) = 0;
    Mirror* m_obj = new Mirror(API->vm->srate(VM));
    OBJ_MEMBER_INT(SELF, mirror4_data_offset) = (t_CKINT)m_obj;
}

CK_DLL_CTOR(mirror4_octor)
{
    OBJ_MEMBER_INT(SELF, mirror4_data_offset) = 0;
    t_CKINT input = GET_NEXT_INT(ARGS); // grab init mode
    Mirror* m_obj = new Mirror(API->vm->srate(VM), input);
    OBJ_MEMBER_INT(SELF, mirror4_data_offset) = (t_CKINT)m_obj;
}

CK_DLL_DTOR(mirror4_dtor)
{
    Mirror* m_obj = (Mirror*)OBJ_MEMBER_INT(SELF, mirror4_data_offset);
    CK_SAFE_DELETE(m_obj);
    OBJ_MEMBER_INT(SELF, mirror4_data_offset) = 0;
}

CK_DLL_TICKF(mirror4_tickf)
{
    Mirror* m_obj = (Mirror*)OBJ_MEMBER_INT(SELF, mirror4_data_offset);
    if (m_obj)
    {
        memset(out, 0, sizeof(SAMPLE) * 25 * nframes); // clear
        for (int f = 0; f < nframes; f++)
        {
            for (int c = 0; c < 25; c++)
            {
                out[f * 25 + c] = in[f * 25 + c] * m_obj->mirrorValues[c]; // search up weights and apply
            }
        }
    }
    return TRUE;
}

CK_DLL_MFUN(mirror4_setMode)
{
    Mirror* m_obj = (Mirror*)OBJ_MEMBER_INT(SELF, mirror4_data_offset);
    t_CKINT arg1 = GET_NEXT_INT(ARGS);

    m_obj->mode(arg1);
}

CK_DLL_MFUN(mirror4_getMode)
{
    Mirror* m_obj = (Mirror*)OBJ_MEMBER_INT(SELF, mirror4_data_offset);
    if (m_obj) RETURN->v_int = m_obj->lastMode;
    else RETURN->v_int = 0;
}

//==============================================================================
CK_DLL_CTOR(mirror5_ctor)
{
    OBJ_MEMBER_INT(SELF, mirror5_data_offset) = 0;
    Mirror* m_obj = new Mirror(API->vm->srate(VM));
    OBJ_MEMBER_INT(SELF, mirror5_data_offset) = (t_CKINT)m_obj;
}

CK_DLL_CTOR(mirror5_octor)
{
    OBJ_MEMBER_INT(SELF, mirror5_data_offset) = 0;
    t_CKINT input = GET_NEXT_INT(ARGS); // grab init mode
    Mirror* m_obj = new Mirror(API->vm->srate(VM), input);
    OBJ_MEMBER_INT(SELF, mirror5_data_offset) = (t_CKINT)m_obj;
}

CK_DLL_DTOR(mirror5_dtor)
{
    Mirror* m_obj = (Mirror*)OBJ_MEMBER_INT(SELF, mirror5_data_offset);
    CK_SAFE_DELETE(m_obj);
    OBJ_MEMBER_INT(SELF, mirror5_data_offset) = 0;
}

CK_DLL_TICKF(mirror5_tickf)
{
    Mirror* m_obj = (Mirror*)OBJ_MEMBER_INT(SELF, mirror5_data_offset);
    if (m_obj)
    {
        memset(out, 0, sizeof(SAMPLE) * 36 * nframes); // clear
        for (int f = 0; f < nframes; f++)
        {
            for (int c = 0; c < 36; c++)
            {
                out[f * 36 + c] = in[f * 36 + c] * m_obj->mirrorValues[c]; // search up weights and apply
            }
        }
    }
    return TRUE;
}

CK_DLL_MFUN(mirror5_setMode)
{
    Mirror* m_obj = (Mirror*)OBJ_MEMBER_INT(SELF, mirror5_data_offset);
    t_CKINT arg1 = GET_NEXT_INT(ARGS);

    m_obj->mode(arg1);
}

CK_DLL_MFUN(mirror5_getMode)
{
    Mirror* m_obj = (Mirror*)OBJ_MEMBER_INT(SELF, mirror5_data_offset);
    if (m_obj) RETURN->v_int = m_obj->lastMode;
    else RETURN->v_int = 0;
}

//==============================================================================